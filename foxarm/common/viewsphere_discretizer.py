import numpy as np

from autolab_core import RigidTransform
from autolab_core.utils import sph2cart

class ViewsphereDiscretizer(object):
    """Set of parameters for automatically rendering a set of images from virtual
    cameras placed around a viewing sphere.

    The view sphere indicates camera poses relative to the object.

    Attributes
    ----------
    min_radius : float
        Minimum radius for viewing sphere.
    max_radius : float
        Maximum radius for viewing sphere.
    num_radii  : int
        Number of radii between min_radius and max_radius.
    min_elev : float
        Minimum elevation (angle from z-axis) for camera position.
    max_elev : float
        Maximum elevation for camera position.
    num_elev  : int
        Number of discrete elevations.
    min_az : float
        Minimum azimuth (angle from x-axis) for camera position.
    max_az : float
        Maximum azimuth for camera position.
    num_az  : int
        Number of discrete azimuth locations.
    min_roll : float
        Minimum roll (rotation of camera about axis generated by azimuth and
        elevation) for camera.
    max_roll : float
        Maximum roll for camera.
    num_roll  : int
        Number of discrete rolls.
    """

    def __init__(self, min_radius, max_radius, num_radii,
                 min_elev, max_elev, num_elev,
                 min_az=0, max_az=2*np.pi, num_az=1,
                 min_roll=0, max_roll=2*np.pi, num_roll=1):
        """Initialize a ViewsphereDiscretizer.

        Parameters
        ----------
        min_radius : float
            Minimum radius for viewing sphere.
        max_radius : float
            Maximum radius for viewing sphere.
        num_radii  : int
            Number of radii between min_radius and max_radius.
        min_elev : float
            Minimum elevation (angle from z-axis) for camera position.
        max_elev : float
            Maximum elevation for camera position.
        num_elev  : int
            Number of discrete elevations.
        min_az : float
            Minimum azimuth (angle from x-axis) for camera position.
        max_az : float
            Maximum azimuth for camera position.
        num_az  : int
            Number of discrete azimuth locations.
        min_roll : float
            Minimum roll (rotation of camera about axis generated by azimuth and
            elevation) for camera.
        max_roll : float
            Maximum roll for camera.
        num_roll  : int
            Number of discrete rolls.
        """
        if num_radii < 1 or num_az < 1 or num_elev < 1:
            raise ValueError('Discretization must be at least one in each dimension')
        self.min_radius = min_radius
        self.max_radius = max_radius
        self.num_radii = num_radii
        self.min_az = min_az
        self.max_az = max_az
        self.num_az = num_az
        self.min_elev = min_elev
        self.max_elev = max_elev
        self.num_elev = num_elev
        self.min_roll = min_roll
        self.max_roll = max_roll
        self.num_roll = num_roll

    def object_to_camera_poses(self):
        """Turn the params into a set of object to camera transformations.

        Returns
        -------
        :obj:`list` of :obj:`RigidTransform`
            A list of rigid transformations that transform from object space
            to camera space.
        """
        # compute increments in radial coordinates
        if self.max_radius == self.min_radius:
            radius_inc = 1
        elif self.num_radii == 1:
            radius_inc = self.max_radius - self.min_radius + 1
        else:
            radius_inc = (self.max_radius - self.min_radius) / (self.num_radii - 1)
        az_inc = (self.max_az - self.min_az) / self.num_az
        if self.max_elev == self.min_elev:
            elev_inc = 1
        elif self.num_elev == 1:
            elev_inc = self.max_elev - self.min_elev + 1
        else:
            elev_inc = (self.max_elev - self.min_elev) / (self.num_elev - 1)
        roll_inc = (self.max_roll - self.min_roll) / self.num_roll

        # create a pose for each set of spherical coords
        object_to_camera_poses = []
        radius = self.min_radius
        while radius <= self.max_radius:
            elev = self.min_elev
            while elev <= self.max_elev:
                az = self.min_az
                while az < self.max_az: #not inclusive due to topology (simplifies things)
                    roll = self.min_roll
                    while roll < self.max_roll:

                        # generate camera center from spherical coords
                        camera_center_obj = np.array([sph2cart(radius, az, elev)]).squeeze()
                        camera_z_obj = -camera_center_obj / np.linalg.norm(camera_center_obj)

                        # find the canonical camera x and y axes
                        camera_x_par_obj = np.array([camera_z_obj[1], -camera_z_obj[0], 0])
                        if np.linalg.norm(camera_x_par_obj) == 0:
                            camera_x_par_obj = np.array([1, 0, 0])
                        camera_x_par_obj = camera_x_par_obj / np.linalg.norm(camera_x_par_obj)
                        camera_y_par_obj = np.cross(camera_z_obj, camera_x_par_obj)
                        camera_y_par_obj = camera_y_par_obj / np.linalg.norm(camera_y_par_obj)
                        if camera_y_par_obj[2] > 0:
                            camera_x_par_obj = -camera_x_par_obj
                            camera_y_par_obj = np.cross(camera_z_obj, camera_x_par_obj)
                            camera_y_par_obj = camera_y_par_obj / np.linalg.norm(camera_y_par_obj)

                        # rotate by the roll
                        R_obj_camera_par = np.c_[camera_x_par_obj, camera_y_par_obj, camera_z_obj]
                        R_camera_par_camera = np.array([[np.cos(roll), -np.sin(roll), 0],
                                                        [np.sin(roll), np.cos(roll), 0],
                                                        [0, 0, 1]])
                        R_obj_camera = R_obj_camera_par.dot(R_camera_par_camera)
                        t_obj_camera = camera_center_obj

                        # create final transform
                        T_obj_camera = RigidTransform(R_obj_camera, t_obj_camera,
                                                      from_frame='camera', to_frame='obj')
                        object_to_camera_poses.append(T_obj_camera.inverse())
                        roll += roll_inc
                    az += az_inc
                elev += elev_inc
            radius += radius_inc
        return object_to_camera_poses
